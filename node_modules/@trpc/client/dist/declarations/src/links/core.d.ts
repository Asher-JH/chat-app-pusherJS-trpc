import { AnyRouter, DataTransformer } from '@trpc/server';
import { TRPCResult } from '@trpc/server/rpc';
import { TRPCClientError } from '../TRPCClientError';
export declare type OperationContext = Record<string, unknown>;
export declare type Operation<TInput = unknown> = {
    id: number;
    type: 'query' | 'mutation' | 'subscription';
    input: TInput;
    path: string;
    context: OperationContext;
};
export declare type OperationResponse<TRouter extends AnyRouter, TOutput = unknown> = TRPCResult<TOutput> | TRPCClientError<TRouter>;
export declare type PrevCallback<TRouter extends AnyRouter, TOutput = unknown> = (result: OperationResponse<TRouter, TOutput>) => void;
export declare type OperationLink<TRouter extends AnyRouter, TInput = unknown, TOutput = unknown> = (opts: {
    op: Operation;
    prev: PrevCallback<TRouter, TOutput>;
    next: (op: Operation<TInput>, callback: PrevCallback<TRouter, TOutput>) => void;
    onDestroy: (callback: () => void) => void;
}) => void;
export declare type TRPCLink<TRouter extends AnyRouter> = (opts: LinkRuntimeOptions) => OperationLink<TRouter>;
export interface HTTPLinkOptions {
    url: string;
}
/**
 * @deprecated use `HTTPLinkOptions`
 */
export declare type HttpLinkOptions = HTTPLinkOptions;
export declare type HTTPHeaders = Record<string, string | string[] | undefined>;
/**
 * The default `fetch` implementation has an overloaded signature. By convention this library
 * only uses the overload taking a string and options object.
 */
export declare type TRPCFetch = (url: string, options?: RequestInit) => Promise<Response>;
export declare type LinkRuntimeOptions = Readonly<{
    transformer: DataTransformer;
    headers: () => HTTPHeaders | Promise<HTTPHeaders>;
    fetch: TRPCFetch;
    AbortController?: typeof AbortController;
}>;
export declare type CancelFn = () => void;
export declare type PromiseAndCancel<TValue> = {
    promise: Promise<TValue>;
    cancel: CancelFn;
};
//# sourceMappingURL=core.d.ts.map