import { createTRPCClient } from '@trpc/client';
export * from '@trpc/client';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import React, { createContext, useState, useEffect, useCallback, useMemo } from 'react';
import { useQuery, useMutation, hashQueryKey, useInfiniteQuery } from 'react-query';

var TRPCContext = /*#__PURE__*/createContext(null);

function getClientArgs(pathAndInput, opts) {
  var _pathAndInput = _slicedToArray(pathAndInput, 2),
      path = _pathAndInput[0],
      input = _pathAndInput[1];

  return [path, input, opts];
}

function createReactQueryHooks() {
  var Context = TRPCContext;

  function createClient(opts) {
    return createTRPCClient(opts);
  }

  function TRPCProvider(props) {
    var client = props.client,
        queryClient = props.queryClient,
        ssrContext = props.ssrContext;

    var _useState = useState(props.ssrState || (props.isPrepass ? 'prepass' : false)),
        _useState2 = _slicedToArray(_useState, 2),
        ssrState = _useState2[0],
        setSSRState = _useState2[1];

    useEffect(function () {
      // Only updating state to `mounted` if we are using SSR.
      // This makes it so we don't have an unnecessary re-render when opting out of SSR.
      setSSRState(function (state) {
        return state ? 'mounted' : false;
      });
    }, []);
    return /*#__PURE__*/React.createElement(Context.Provider, {
      value: {
        queryClient: queryClient,
        client: client,
        isPrepass: ssrState === 'prepass',
        ssrContext: ssrContext || null,
        ssrState: ssrState,
        fetchQuery: useCallback(function (pathAndInput, opts) {
          return queryClient.fetchQuery(pathAndInput, function () {
            var _ref;

            return (_ref = client).query.apply(_ref, _toConsumableArray(getClientArgs(pathAndInput, opts)));
          }, opts);
        }, [client, queryClient]),
        fetchInfiniteQuery: useCallback(function (pathAndInput, opts) {
          return queryClient.fetchInfiniteQuery(pathAndInput, function (_ref2) {
            var _ref3;

            var pageParam = _ref2.pageParam;

            var _pathAndInput2 = _slicedToArray(pathAndInput, 2),
                path = _pathAndInput2[0],
                input = _pathAndInput2[1];

            var actualInput = _objectSpread(_objectSpread({}, input), {}, {
              cursor: pageParam
            });

            return (_ref3 = client).query.apply(_ref3, _toConsumableArray(getClientArgs([path, actualInput], opts)));
          }, opts);
        }, [client, queryClient]),
        prefetchQuery: useCallback(function (pathAndInput, opts) {
          return queryClient.prefetchQuery(pathAndInput, function () {
            var _ref4;

            return (_ref4 = client).query.apply(_ref4, _toConsumableArray(getClientArgs(pathAndInput, opts)));
          }, opts);
        }, [client, queryClient]),
        prefetchInfiniteQuery: useCallback(function (pathAndInput, opts) {
          return queryClient.prefetchInfiniteQuery(pathAndInput, function (_ref5) {
            var _ref6;

            var pageParam = _ref5.pageParam;

            var _pathAndInput3 = _slicedToArray(pathAndInput, 2),
                path = _pathAndInput3[0],
                input = _pathAndInput3[1];

            var actualInput = _objectSpread(_objectSpread({}, input), {}, {
              cursor: pageParam
            });

            return (_ref6 = client).query.apply(_ref6, _toConsumableArray(getClientArgs([path, actualInput], opts)));
          }, opts);
        }, [client, queryClient]),

        /**
         * @deprecated use `invalidateQueries`
         */
        invalidateQuery: useCallback(function () {
          return queryClient.invalidateQueries.apply(queryClient, arguments);
        }, [queryClient]),
        invalidateQueries: useCallback(function () {
          return queryClient.invalidateQueries.apply(queryClient, arguments);
        }, [queryClient]),
        refetchQueries: useCallback(function () {
          return queryClient.refetchQueries.apply(queryClient, arguments);
        }, [queryClient]),
        cancelQuery: useCallback(function (pathAndInput) {
          return queryClient.cancelQueries(pathAndInput);
        }, [queryClient]),
        setQueryData: useCallback(function () {
          return queryClient.setQueryData.apply(queryClient, arguments);
        }, [queryClient]),
        getQueryData: useCallback(function () {
          return queryClient.getQueryData.apply(queryClient, arguments);
        }, [queryClient]),
        setInfiniteQueryData: useCallback(function () {
          return queryClient.setQueryData.apply(queryClient, arguments);
        }, [queryClient]),
        getInfiniteQueryData: useCallback(function () {
          return queryClient.getQueryData.apply(queryClient, arguments);
        }, [queryClient])
      }
    }, props.children);
  }

  function useContext() {
    return React.useContext(Context);
  }
  /**
   * Hack to make sure errors return `status`='error` when doing SSR
   * @link https://github.com/trpc/trpc/pull/1645
   */


  function useSSRQueryOptionsIfNeeded(pathAndInput, opts) {
    var _queryClient$getQuery;

    var _useContext = useContext(),
        queryClient = _useContext.queryClient,
        ssrState = _useContext.ssrState;

    return ssrState && ssrState !== 'mounted' && ((_queryClient$getQuery = queryClient.getQueryCache().find(pathAndInput)) === null || _queryClient$getQuery === void 0 ? void 0 : _queryClient$getQuery.state.status) === 'error' ? _objectSpread({
      retryOnMount: false
    }, opts) : opts;
  }

  function useQuery$1(pathAndInput, opts) {
    var _useContext2 = useContext(),
        client = _useContext2.client,
        isPrepass = _useContext2.isPrepass,
        queryClient = _useContext2.queryClient,
        prefetchQuery = _useContext2.prefetchQuery;

    if (typeof window === 'undefined' && isPrepass && (opts === null || opts === void 0 ? void 0 : opts.ssr) !== false && (opts === null || opts === void 0 ? void 0 : opts.enabled) !== false && !queryClient.getQueryCache().find(pathAndInput)) {
      prefetchQuery(pathAndInput, opts);
    }

    var actualOpts = useSSRQueryOptionsIfNeeded(pathAndInput, opts);
    return useQuery(pathAndInput, function () {
      var _ref7;

      return (_ref7 = client).query.apply(_ref7, _toConsumableArray(getClientArgs(pathAndInput, actualOpts)));
    }, actualOpts);
  }

  function useMutation$1(path, opts) {
    var _useContext3 = useContext(),
        client = _useContext3.client;

    return useMutation(function (input) {
      var actualPath = Array.isArray(path) ? path[0] : path;
      return client.mutation(actualPath, input, opts);
    }, opts);
  }
  /* istanbul ignore next */

  /**
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️
   *  **Experimental.** API might change without major version bump
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠
   */


  function useSubscription(pathAndInput, opts) {
    var _opts$enabled;

    var enabled = (_opts$enabled = opts === null || opts === void 0 ? void 0 : opts.enabled) !== null && _opts$enabled !== void 0 ? _opts$enabled : true;
    var queryKey = hashQueryKey(pathAndInput);

    var _useContext4 = useContext(),
        client = _useContext4.client;

    return useEffect(function () {
      if (!enabled) {
        return;
      }

      var _pathAndInput4 = _slicedToArray(pathAndInput, 2),
          path = _pathAndInput4[0],
          input = _pathAndInput4[1];

      var isStopped = false;
      var unsub = client.subscription(path, input !== null && input !== void 0 ? input : undefined, {
        onError: function onError(err) {
          if (!isStopped) {
            var _opts$onError;

            (_opts$onError = opts.onError) === null || _opts$onError === void 0 ? void 0 : _opts$onError.call(opts, err);
          }
        },
        onNext: function onNext(res) {
          if (res.type === 'data' && !isStopped) {
            opts.onNext(res.data);
          }
        }
      });
      return function () {
        isStopped = true;
        unsub();
      }; // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [queryKey, enabled]);
  }

  function useInfiniteQuery$1(pathAndInput, opts) {
    var _pathAndInput5 = _slicedToArray(pathAndInput, 2),
        path = _pathAndInput5[0],
        input = _pathAndInput5[1];

    var _useContext5 = useContext(),
        client = _useContext5.client,
        isPrepass = _useContext5.isPrepass,
        prefetchInfiniteQuery = _useContext5.prefetchInfiniteQuery,
        queryClient = _useContext5.queryClient;

    if (typeof window === 'undefined' && isPrepass && (opts === null || opts === void 0 ? void 0 : opts.ssr) !== false && (opts === null || opts === void 0 ? void 0 : opts.enabled) !== false && !queryClient.getQueryCache().find(pathAndInput)) {
      prefetchInfiniteQuery(pathAndInput, opts);
    }

    var actualOpts = useSSRQueryOptionsIfNeeded(pathAndInput, opts);
    return useInfiniteQuery(pathAndInput, function (_ref8) {
      var _ref9, _ref10;

      var pageParam = _ref8.pageParam;

      var actualInput = _objectSpread(_objectSpread({}, (_ref9 = input) !== null && _ref9 !== void 0 ? _ref9 : {}), {}, {
        cursor: pageParam
      });

      return (_ref10 = client).query.apply(_ref10, _toConsumableArray(getClientArgs([path, actualInput], actualOpts)));
    }, actualOpts);
  }

  function useDehydratedState(client, trpcState) {
    var transformed = useMemo(function () {
      if (!trpcState) {
        return trpcState;
      }

      return client.runtime.transformer.deserialize(trpcState);
    }, [client, trpcState]);
    return transformed;
  }

  return {
    Provider: TRPCProvider,
    createClient: createClient,
    useContext: useContext,
    useQuery: useQuery$1,
    useMutation: useMutation$1,
    useSubscription: useSubscription,
    useDehydratedState: useDehydratedState,
    useInfiniteQuery: useInfiniteQuery$1
  };
}

export { createReactQueryHooks };
